# 變數 (Varialbe)

## 資料型態

- 原始型態 (primitive type)

    1. null
    2. undefined
    3. string
    4. number
    5. boolean
    6. symbol (ES6)

- 物件型態 (object type)

    7. object(array, function, date)

## typeof

要知道型態，可以使用 `typeof` 這個語法

```javascript
// 兩種寫法都 OK
console.log(typeof a)
console.log(typeof(a))
```

如果你的引數是放一個 Array，那麼它會顯示 object，這可以理解，因為 Array 被歸類為 object

但是如果你是放的是 function，則會顯示 function

```javascript
console.log(typeof []) // object
console.log(typeof function() {}) // function
```

另外我們看看下列這個例子

```javascript
var a
console.log(typeof a) // undefined
console.log(typeof b) // undefined
```

在上面這個例子，一個是已宣告但未賦值的變數，另一個是從未宣告，都會顯示 undefined

利用這個特性，我們可以利用 `typeof` 判斷一個變數是否存在並被賦值，應用在我們的判斷式

```javascript
if (typeof a !== 'undefined') {       // 記得 undefined 是字串
    // 判斷式內容
}
```

**在 JavaScript 中，對 null 使用 `typeof` 也會回傳 object，這應該是老生常談的 bug**

MDN 官方文件也有寫到這一點

![](./img/1.jpg)

官方文件很棒，也直接幫我們列好[清單](https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Operators/typeof)了

![](./img/2.jpg)

由此可見 `typeof` 不一定能應付各種狀況，比如它就無法明確告訴開發者，一個變數裡放的是不是 Array

但以這個例子來說，我們有 `Array.isArray()`

另外這邊也提一下一個用法，那就是 `Object.prototype.toString.call()`

```javascript
console.log(Object.prototype.toString.call(4) // [object Number]
console.log(Object.prototype.toString.call('a') // [object String]
console.log(Object.prototype.toString.call([]) // [object Array]
console.log(Object.prototype.toString.call(Null) // [object Null]
```

## 原始型態不可變

在 Week5 總複習有特別提到，primitive type 不可變，不要和**對變數重新賦值**搞混了

```javascript
var a = 'aaa'
a.toUpperCase()
console.log(a) // aaa
```
我們都知道在 JavaScript 中，有些內建的方法會直接改變對象的值，比如說 `.pop()` 會直接改變對象陣列，那現在我們知道 Array 是物件型別，**物件型別是可變的**

相反的，原始型態不可變，所以就上述程式碼的例子來說，`toUpperCase()` 並不會改變 `a` 的值，而是會 return 一個處理過的值，所以我們通常會用一個變數去接住它，改成下面看看：

```javascript
var a = 'aaa'
var A = a.toUpperCase()
console.log(A) // AAA
```

至此，我們可以明白，`a === 'aaa'` 不會改變，除非我們重新對 `a` 賦值

結論 :

> *原始型態不可變，而物件型態可變*

## 賦值



# 作用域 (Scope)

# 從 Hoisting 開始了解底層運作

# 從閉包 (Closure) 更進一步了解

# 物件導向基礎與 Prototype

# this