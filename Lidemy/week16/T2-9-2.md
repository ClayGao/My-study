# 前言

開宗明義今天所述的課程內容有一定難度，主要會集中在 Javascript

# Hoisting 提升

思考下列兩者的差別

```javascript
console.log(a); // undefined
var a = 1;
```

```javascript
console.log(b); // b is not defined
var a = 1;
```

所以變數**提升**的意思是什麼 ?

為什麼兩者的錯誤訊息會不同呢 ?

第一段程式碼我們可以拆成以下

```javascript
console.log(a); // undefined
var a; // 宣告
a = 1; // 賦值
```

但是對於 Javascript，當需要呼叫一個變數，而全域內有變數，但還會讀到時，Javascript 會自動把該變數 hoisting 到上面來，所以可以看成這樣

```javascript
var a; // 宣告 - 變數被提升
console.log(a); // undefined
a = 1; // 賦值
```

-----

再看第二個案例，函式的案例

在某些程式語言之中，有些程式語言的規則是函式需要**先宣告**才能使用，但 JS 不用 (儘管 Eslint 也會跟你說不能) 先宣告函式，先呼叫也 OK

```javascript
test();

function test() {
    console.log("函式執行成功 !"); 
}
```

# Closure 閉包

來看看以下程式碼

```javascript
function test() {
    var a = 10;
    console.log(a); // 10
}

test();
console.log(a); // a  is not defined
```

- 原理 : 

    當 function 執行完之後，內中的變數和內容會被**釋放**，所以對渥面的區域來說，變數 a 是不存在的

    第二個原因是因為作用域不同，外面是看不到裡面的變數，而這是**作用域概念**

## 閉包用在哪 ?

參考以下案例

```javascript
var count = 0;
function addCount(){
    count++;
    return count;
}

console.log(addCount()); // 呼叫第一次
console.log(addCount()); // 呼叫第二次
```

這樣每呼叫一次，就可以計數了

但這樣有一個缺點，Count 本身在全域的部分也可以被使用到，這時候如果別人改到程式碼輸入 `count = 10`，計數就和預期不同了

為了達到使變數無法被修改的目的，所以我們可以這樣寫

```javascript
function addCount(){
    var count = 0;
    count++;
    return count;
}

console.log(addCount()); // 呼叫第一次
console.log(addCount()); // 呼叫第二次
```
如此會輸出

```
1
1
```

所以問題是，我們要怎麼讓函式被呼叫的時候忽略 `var count = 0;`，直接 count++ 呢 ?

方法是將兩個工作分開，在裡面創計步函式，並且回傳函式結果

```javascript
function createCounter() {
    var count = 0;
    function counter() {
        count++;
        return count;
    }
    return counter;
}

var counter = createCounter();
console.log(counter());
console.log(counter());
```
如此會輸出

```
1
2
```
**閉包**的使用型態就是用一個函式裡面再包一個函式，並 retrun 該函式

從這邊可以發現，用函式包起來是為了讓全域不要用到我們的變數，**利用函式創造新的作用域**就是我們的手段

這就是**閉包**的原理

習慣後也可以寫成這樣 :

```javascript
function createCounter() {
    var count = 0;
    return function() {
        count++;
        return count;
    }
}

var counter = createCounter();
console.log(counter());
console.log(counter());
```

回到我們最初討論的幾個特性

1. 函式執行過後，內中的東西會被**釋放**，但是閉包的特性使其**保存**，可以繼續沿用下去，比如說上述案例的 `count`

2. 閉包的特性可以讓我們在外呼叫內部函式 (用 return 串接)

繼續看下一個重點，這樣使用的話我們就可以用一套同樣的邏輯去計算兩個我要計算的變數

```javascript
function createCounter() {
    var count = 0;
    return function() {
        count++;
        return count;
    }
}

var counterA = createCounter();
var counterB = createCounter();
console.log(counterA());
console.log(counterA());
console.log(counterB());
console.log(counterB());
console.log(counterB());
```

如此會輸出

```
1
2
1
2
3
```
兩者之所以會分開計算，是因為看似是用同一個 `createCounter()`，但實際上回傳的內容屬於**不同的記憶體位置**，所以 `counterA === counterB 為 false`，可以回到[第五週的心得](..week5/week1-4.md)複習記憶體位置概念

另外請注意`var counterA = createCounter();` 其實只**執行**裡面包著的那個函式的內容！這邊由 `return function(){}` 可以見得 (影片 18:45)

參考網址 : https://pjchender.blogspot.com/2017/05/javascript-closure.html

# Prototype

```javascript

```

由於 ES5 沒有內建 OOP，所以以下都是這樣創建建構子來使用 OOP

```javascript
fucntion Person(name) {
    this.name = 'nick';
}

var nick = new Person('Nick');
var peter = new Person('Peter');
console.log(nick.name, peter.name) // Nick, Peter
```

那現在除了設定 name 之外，這邊還想多做一些事情

```javascript
fucntion Person(name) {
    this.name = name;
    this.getName = function() {
        return this.name;
    }
}

var nick = new Person('Nick');
var peter = new Person('Peter');
console.log(nick.name, peter.name) // Nick, Peter
console.log(nick.getName(), peter.name) // Nick
```

但是注意，若這時候輸入 `console.log(nick.getName === peter.getName)` 會是 `false`，因為兩者的 function 的記憶體位置不同，所以是兩個不同的 function

那要如何讓兩者相等呢 ?

```javascript
fucntion Person(name) {
    this.name = name;
}

Person.prototype.getName = function() {
    return this.name;
}

var nick = new Person('Nick');
var peter = new Person('Peter');
console.log(nick.name, peter.name) // Nick, Peter
console.log(nick.getName(), peter.name) // Nick

console.log(nick.getName === peter.getName) // true
```
要注意的是，即使是這樣的寫法，但 `nick.getName()` 還是會先從 `function Person(){}` 裡面開始找，若找不到，才會找到 `Person.prototype.getName`

**也就是說，在 JS 裡面的運作是，會先從 intence 開始找，若找不到，就去找 Prototype**

找到之後就會使用了，但**如果仍找不到，就會再往更上層找**

這時候，`console.log(nick.getName === Person.prototype.getName) // true`，他們是同一個 function

那這時候可以明白，呼叫時引擎之所以知道要找 prototype，肯定是因為有一個東西將他們之間的關係串連起來了，那就是隱藏屬性 __proto__，它的目的就是如果底層找不到東西，它會指引妳去哪裏找，這個隱藏屬性在每一次你創建一個 intance 的時候就會出現

`console.log(nick.__proto___ === Person.prototype) // true`

所以可以這樣理解，如果在 nick 找不到，其實就會找向 `nick.__proto___`，而這時候的的　`nick.__proto___`　則是　`Person.prototype`

如果要研究更深，其實重點就是 `new` 這個關鍵字，

其實 `var nick = new Person('Nick');` 這個甕做可以看成以下

```javascript
var obj = {
    name = 'nick';
}
obj.__proto__ = Person.prototype
```
那如果還是找不到呢 ? 整理一下步驟

1. nick 找不到，就去找 nick.__proto__(Person.prototype)
2. 仍找不到，就去 nick.__proto__.__proto__(Person.prototype.__ptoto__)
...
...

```javascript
console.log(nick.__proto___ === Person.prototype) // true
console.log(Person.prototype.__proto___ === Object.prototype) // true
```

從 Boolean 為 true，可以知道其代表的東西是一樣的，而這邊找到就停了

請注意尋找的順序是如上所述，跟函式的宣告順序**沒有關係**

這樣的尋找順序可以看做是一條鍊，我們稱為**原型鍊 prototype chain**

# 程式執行原理 Stack

## 程式是怎麼執行的 ?

Stack 是一個資料結構，並且會符合它所屬資料結構的**特性**

在 JS 中稱之為 **Call Stack**，這個資料結構解釋了 JS 底層是如何執行的

Call Stack 符合 LIFO ，當程式在跑的時候，就會依照這個結構來跑，**Call** 的意思就是 Fubction call，也就是說 Javascript 底層運行的特性是符合 Stack 

*關於 LIFO，可以當作餐廳疊的餐盤，最後放上去的一定最先被取走*

另外這邊要記住，**要 function call 才會入 Stack，宣告 function 不會**

看看以下這個例子

```javascript

```


```javascript
function a() {
    b();
}

function b() {
    c()
}

function c(){
    console.log(ddd)
}

a()
```

這邊可以預測得到 Stack 應該如下

| Stack |
|:-----:|
| c()   |
| b()   |
| a()   |

上述的 `console.log(ddd)` 是故意打錯的，可以看一下用 node 執行這個 js 所產生的錯誤訊息如下

```
λ node index.js
C:\Users\USER\Desktop\index.js:10
    console.log(ddd)
                ^

ReferenceError: ddd is not defined
    at c (C:\Users\USER\Desktop\index.js:10:17) 
    at b (C:\Users\USER\Desktop\index.js:6:5)
    at a (C:\Users\USER\Desktop\index.js:2:5)
    at Object.<anonymous> (C:\Users\USER\Desktop\index.js:13:1)
    at Module._compile (internal/modules/cjs/loader.js:701:30)
    at Object.Module._extensions..js (internal/modules/cjs/loader.js:712:10)
    at Module.load (internal/modules/cjs/loader.js:600:32)
    at tryModuleLoad (internal/modules/cjs/loader.js:539:12)
    at Function.Module._load (internal/modules/cjs/loader.js:531:3)
    at Function.Module.runMain (internal/modules/cjs/loader.js:754:12)
```
其中下列三行就是 Call Stark 的內容，可以看到符合 LIFO 原則

```
at c (C:\Users\USER\Desktop\index.js:10:17) 
at b (C:\Users\USER\Desktop\index.js:6:5)
at a (C:\Users\USER\Desktop\index.js:2:5)
```

而以下部分就是 JS 內建的一些 Function

```
at Object.<anonymous> (C:\Users\USER\Desktop\index.js:13:1)
at Module._compile (internal/modules/cjs/loader.js:701:30)
at Object.Module._extensions..js (internal/modules/cjs/loader.js:712:10)
at Module.load (internal/modules/cjs/loader.js:600:32)
at tryModuleLoad (internal/modules/cjs/loader.js:539:12)
at Function.Module._load (internal/modules/cjs/loader.js:531:3)
at Function.Module.runMain (internal/modules/cjs/loader.js:754:12)
```
又或者你這樣寫

```javascript
function a() {
    a();
}

a();
```

這樣寫就是會無限呼叫，可以大概猜到 Stack 也會無限循環

```
λ node index.js
C:\Users\USER\Desktop\index.js:1
(function (exports, require, module, __filename, __dirname) { function a() {
                                                                        ^

RangeError: Maximum call stack size exceeded
    at a (C:\Users\USER\Desktop\index.js:1:73)
    at a (C:\Users\USER\Desktop\index.js:2:5)
    at a (C:\Users\USER\Desktop\index.js:2:5)
    at a (C:\Users\USER\Desktop\index.js:2:5)
    at a (C:\Users\USER\Desktop\index.js:2:5)
    at a (C:\Users\USER\Desktop\index.js:2:5)
    at a (C:\Users\USER\Desktop\index.js:2:5)
    at a (C:\Users\USER\Desktop\index.js:2:5)
    at a (C:\Users\USER\Desktop\index.js:2:5)
    at a (C:\Users\USER\Desktop\index.js:2:5)
```

果不其然，這就會造成 **Stack Overflow** 現象

# Javascript 是怎麼執行的 ?

## 編譯與執行

這是錯誤的，否則 Hoisting 就不會存在了

也就是說在 JS 底層，程式不是第一行接著一行跑的

JS 運行是分兩階段的

> 編譯 -> 執行

在**執行階段**，程式的確是一行一行跑的，而為了能順利執行，JS 在**編譯階段**就會做一些操作，現在讓我們來看看

## Execution Content 執行環境

看看以下這個 Call Stack
    
```javascript
fun C
fun B
fun A
```

在 Call Stack 裡面堆疊的其實不只是 function 而已，我們要拆成更細來看，其實在 Stack 堆疊的是一種稱為**執行環境** (以下簡稱**EC**) 的東西，而 EC 本身其實是個物件，物件的內容記錄著該函式的細節

所以更正確地說，在 Stack 存放的不只是 function，而是**該 Function 的執行環境**

```javascript
EC of fun C
EC of fun B
EC of fun A

global EC 
// 以前有提過其實一個 .js 本身就是一個大 function，所以本身是 EC 也是很正常的一件事
```

一個 EC 的構造如下 (其實就是一個 Javascript 的物件):

```javascript
EC : {
    Variable Object, // 簡稱 VO
    scopeChain, // 
    this
}
```
再分解來看

```javascript
EC : {
    VO: {
        argument: {
            // h存放該函式參數
        },
        // 存放該函式變數
    }
    scopeChain: [] // 是一個 array，存跟範疇有關的 chaining
    this // 惡名昭彰的 this
}
```
## 跑一波

現在我們來跑看看

```javascript
    console.log(a);
    var a = 7;
    function getTheWord() {
        var b = 3;
        var c = 15;
        a = 9;
        function inner() {
            var d = 80;
            console.log(b)
        }
        inner();
    }

getTheWord();
```

- Round 1

    > 1. global EC => 編譯階段

    由於 .js 檔案本身就是一個最外圍的大 Function，所以先跑 Global EC，也可以理解成最外圍的環境

    - Function call => Pass
    - 賦值 => Pass

    程式碼 :

    ```javascript
    console.log(a); // Pass
    var a = 7; // *1，但賦值 Pass，因為其是 var a & a = 1 兩個動作
    function getTheWord(e) { // *2
        var b = 3;
        var c = 15;
        a = 9;
        function inner() {
            var d = 80;
            console.log(b)
        }
        inner();
    }

    getTheWord(32);
    ```

    Call Stack :

    ```javascript
    globalEC: {
        VO: {
            a: undefined // *1
            getTheWord: 0x02 // *2，存入一個記憶體位置
        },
        scopeChain: [globalEC.VO] 
        this: ... 
    }

    ```
    
    Round 1 編譯完成

- Round 2

    > 2. global EC => 執行階段

    step1 :

    ```javascript
    console.log(a); // *1 執行
    var a = 7; 
    function getTheWord(e) { 
        var b = 3;
        var c = 15;
        a = 9;
        function inner() {
            var d = 80;
            console.log(b)
        }
        inner();
    }

    getTheWord(32);
    ```
    Call Stack

    ```javascript
    console.log(undefined) // *1 找 VO 內的 a，印出 undefined，並移出
    globalEC: {
        VO: {
            a: undefined,
            getTheWord: 0x02 
        },
        scopeChain: [globalEC.VO] 
        this: ... 
    }
    ```
    step2 :

    ```javascript
    console.log(a); 
    var a = 7; // *2 執行
    function getTheWord(e) { 
        var b = 3;
        var c = 15;
        a = 9;
        function inner() {
            var d = 80;
            console.log(b)
        }
        inner();
    }

    getTheWord(32);
    ```
    Call Stack

    ```javascript
    globalEC: {
        VO: {
            a: 7,  // *2 執行，找到 VO 的 a，並賦值 7
            getTheWord: 0x02 
        },
        scopeChain: [globalEC.VO] 
        this: ... 
    }
    ```

- Round 3

    > 3. getTheWord EC => 編譯階段

    ```javascript
    console.log(a); 
    var a = 7; 
    function getTheWord(e) {  // *1 紀錄參數長度
        var b = 3; // *2 
        var c = 15; // *3
        a = 9; // Pass
        function inner() { // *4
            var d = 80;
            console.log(b)
        }
        inner(); // Pass
    }

    getTheWord(32); // *1 編譯這個 function
    ```
    Call Stack

    ```javascript
    // *1
    getTheWordEC: {
        VO: {
            arguments :{
                length: 1, // *1，e 長度為 1
                e: 32　// *1
            },
            b: undefined, // *2 
            c: undefined, // *3
            inner: 0x05 // 寫入 inner 這個函式的記憶體位置
        }
        scopeChain: [getTheWord.VO,  globalEC.VO],
        this: ...
    }
    
    globalEC: {
        VO: {
            a: 7,
            getTheWord: 0x02 
        },
        scopeChain: [globalEC.VO] 
        this: ... 
    }
    ```

- Round 4

    > 3. getTheWord EC => 執行階段

    ```javascript
    console.log(a); 
    var a = 7; 
    function getTheWord(e) {  
        var b = 3; // *1
        var c = 15; // *2
        a = 9;  // *3，重點
        function inner() { 
            var d = 80;
            console.log(b)
        }
        inner(); // *4
    }

    getTheWord(32); 
    ```
    Call Stack

    ```javascript
    getTheWordEC: {
        VO: {
            arguments :{
                length: 1, 
                e: 32　
            },
            b: 3, // *1 更新成 3
            c: 15, // *2 更新成 15
            inner: 0x05 
        }
        scopeChain: [getTheWord.VO,  globalEC.VO], // *3 在這層 EC 的 VO 找不到 a，因此透過，scopeChain 找 globalEC.VO 
        this: ...
    }
    
    // *3 找 globalEC.VO 
    globalEC: {
        VO: {
            a: 9, // *3 透過 scopeChain 找到，更新為 9
            getTheWord: 0x02 
        },
        scopeChain: [globalEC.VO] 
        this: ... 
    }
    ```