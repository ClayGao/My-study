# 前言

開宗明義今天所述的課程內容有一定難度，主要會集中在 Javascript

# Hoisting 提升

思考下列兩者的差別

```javascript
console.log(a); // undefined
var a = 1;
```

```javascript
console.log(b); // b is not defined
var a = 1;
```

所以變數**提升**的意思是什麼 ?

為什麼兩者的錯誤訊息會不同呢 ?

第一段程式碼我們可以拆成以下

```javascript
console.log(a); // undefined
var a; // 宣告
a = 1; // 賦值
```

但是對於 Javascript，當需要呼叫一個變數，而全域內有變數，但還會讀到時，Javascript 會自動把該變數 hoisting 到上面來，所以可以看成這樣

```javascript
var a; // 宣告 - 變數被提升
console.log(a); // undefined
a = 1; // 賦值
```

-----

再看第二個案例，函式的案例

在某些程式語言之中，有些程式語言的規則是函式需要**先宣告**才能使用，但 JS 不用 (儘管 Eslint 也會跟你說不能) 先宣告函式，先呼叫也 OK

```javascript
test();

function test() {
    console.log("函式執行成功 !"); 
}
```

# Closure 閉包

來看看以下程式碼

```javascript
function test() {
    var a = 10;
    console.log(a); // 10
}

test();
console.log(a); // a  is not defined
```

- 原理 : 

    當 function 執行完之後，內中的變數和內容會被**釋放**，所以對渥面的區域來說，變數 a 是不存在的

    第二個原因是因為作用域不同，外面是看不到裡面的變數，而這是**作用域概念**

## 閉包用在哪 ?

參考以下案例

```javascript
var count = 0;
function addCount(){
    count++;
    return count;
}

console.log(addCount()); // 呼叫第一次
console.log(addCount()); // 呼叫第二次
```

這樣每呼叫一次，就可以計數了

但這樣有一個缺點，Count 本身在全域的部分也可以被使用到，這時候如果別人改到程式碼輸入 `count = 10`，計數就和預期不同了

為了達到使變數無法被修改的目的，所以我們可以這樣寫

```javascript
function addCount(){
    var count = 0;
    count++;
    return count;
}

console.log(addCount()); // 呼叫第一次
console.log(addCount()); // 呼叫第二次
```
如此會輸出

```
1
1
```

所以問題是，我們要怎麼讓函式被呼叫的時候忽略 `var count = 0;`，直接 count++ 呢 ?

方法是將兩個工作分開，在裡面創計步函式，並且回傳函式結果

```javascript
function createCounter() {
    var count = 0;
    function counter() {
        count++;
        return count;
    }
    return counter;
}

var counter = createCounter();
console.log(counter());
console.log(counter());
```
如此會輸出

```
1
2
```
**閉包**的使用型態就是用一個函式裡面再包一個函式，並 retrun 該函式

從這邊可以發現，用函式包起來是為了讓全域不要用到我們的變數，**利用函式創造新的作用域**就是我們的手段

這就是**閉包**的原理

習慣後也可以寫成這樣 :

```javascript
function createCounter() {
    var count = 0;
    return function() {
        count++;
        return count;
    }
}

var counter = createCounter();
console.log(counter());
console.log(counter());
```

回到我們最初討論的幾個特性

1. 函式執行過後，內中的東西會被**釋放**，但是閉包的特性使其**保存**，可以繼續沿用下去

2. 閉包的特性可以讓我們在外呼叫內部函式 (用 return 串接)

參考網址 : https://pjchender.blogspot.com/2017/05/javascript-closure.html
