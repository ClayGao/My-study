# 前言

開宗明義今天所述的課程內容有一定難度，主要會集中在 Javascript

# Hoisting 提升

思考下列兩者的差別

```javascript
console.log(a); // undefined
var a = 1;
```

```javascript
console.log(b); // b is not defined
var a = 1;
```

所以變數**提升**的意思是什麼 ?

為什麼兩者的錯誤訊息會不同呢 ?

第一段程式碼我們可以拆成以下

```javascript
console.log(a); // undefined
var a; // 宣告
a = 1; // 賦值
```

但是對於 Javascript，當需要呼叫一個變數，而全域內有變數，但還會讀到時，Javascript 會自動把該變數 hoisting 到上面來，所以可以看成這樣

```javascript
var a; // 宣告 - 變數被提升
console.log(a); // undefined
a = 1; // 賦值
```

-----

再看第二個案例，函式的案例

在某些程式語言之中，有些程式語言的規則是函式需要**先宣告**才能使用，但 JS 不用 (儘管 Eslint 也會跟你說不能) 先宣告函式，先呼叫也 OK

```javascript
test();

function test() {
    console.log("函式執行成功 !"); 
}
```

# Closure 閉包

來看看以下程式碼

```javascript
function test() {
    var a = 10;
    console.log(a); // 10
}

test();
console.log(a); // a  is not defined
```

- 原理 : 

    當 function 執行完之後，內中的變數和內容會被**釋放**，所以對渥面的區域來說，變數 a 是不存在的

    第二個原因是因為作用域不同，外面是看不到裡面的變數，而這是**作用域概念**

## 閉包用在哪 ?

參考以下案例

```javascript
var count = 0;
function addCount(){
    count++;
    return count;
}

console.log(addCount()); // 呼叫第一次
console.log(addCount()); // 呼叫第二次
```

這樣每呼叫一次，就可以計數了

但這樣有一個缺點，Count 本身在全域的部分也可以被使用到，這時候如果別人改到程式碼輸入 `count = 10`，計數就和預期不同了

為了達到使變數無法被修改的目的，所以我們可以這樣寫

```javascript
function addCount(){
    var count = 0;
    count++;
    return count;
}

console.log(addCount()); // 呼叫第一次
console.log(addCount()); // 呼叫第二次
```
如此會輸出

```
1
1
```

所以問題是，我們要怎麼讓函式被呼叫的時候忽略 `var count = 0;`，直接 count++ 呢 ?

方法是將兩個工作分開，在裡面創計步函式，並且回傳函式結果

```javascript
function createCounter() {
    var count = 0;
    function counter() {
        count++;
        return count;
    }
    return counter;
}

var counter = createCounter();
console.log(counter());
console.log(counter());
```
如此會輸出

```
1
2
```
**閉包**的使用型態就是用一個函式裡面再包一個函式，並 retrun 該函式

從這邊可以發現，用函式包起來是為了讓全域不要用到我們的變數，**利用函式創造新的作用域**就是我們的手段

這就是**閉包**的原理

習慣後也可以寫成這樣 :

```javascript
function createCounter() {
    var count = 0;
    return function() {
        count++;
        return count;
    }
}

var counter = createCounter();
console.log(counter());
console.log(counter());
```

回到我們最初討論的幾個特性

1. 函式執行過後，內中的東西會被**釋放**，但是閉包的特性使其**保存**，可以繼續沿用下去，比如說上述案例的 `count`

2. 閉包的特性可以讓我們在外呼叫內部函式 (用 return 串接)

繼續看下一個重點，這樣使用的話我們就可以用一套同樣的邏輯去計算兩個我要計算的變數

```javascript
function createCounter() {
    var count = 0;
    return function() {
        count++;
        return count;
    }
}

var counterA = createCounter();
var counterB = createCounter();
console.log(counterA());
console.log(counterA());
console.log(counterB());
console.log(counterB());
console.log(counterB());
```

如此會輸出

```
1
2
1
2
3
```
兩者之所以會分開計算，是因為看似是用同一個 `createCounter()`，但實際上回傳的內容屬於**不同的記憶體位置**，所以 `counterA === counterB 為 false`，可以回到[第五週的心得](..week5/week1-4.md)複習記憶體位置概念

另外請注意`var counterA = createCounter();` 其實只**執行**裡面包著的那個函式的內容！這邊由 `return function(){}` 可以見得 (影片 18:45)

參考網址 : https://pjchender.blogspot.com/2017/05/javascript-closure.html

# Prototype

```javascript

```

由於 ES5 沒有內建 OOP，所以以下都是這樣創建建構子來使用 OOP

```javascript
fucntion Person(name) {
    this.name = 'nick';
}

var nick = new Person('Nick');
var peter = new Person('Peter');
console.log(nick.name, peter.name) // Nick, Peter
```

那現在除了設定 name 之外，這邊還想多做一些事情

```javascript
fucntion Person(name) {
    this.name = name;
    this.getName = function() {
        return this.name;
    }
}

var nick = new Person('Nick');
var peter = new Person('Peter');
console.log(nick.name, peter.name) // Nick, Peter
console.log(nick.getName(), peter.name) // Nick
```

但是注意，若這時候輸入 `console.log(nick.getName === peter.getName)` 會是 `false`，因為兩者的 function 的記憶體位置不同，所以是兩個不同的 function

那要如何讓兩者相等呢 ?

```javascript
fucntion Person(name) {
    this.name = name;
}

Person.prototype.getName = function() {
    return this.name;
}

var nick = new Person('Nick');
var peter = new Person('Peter');
console.log(nick.name, peter.name) // Nick, Peter
console.log(nick.getName(), peter.name) // Nick

console.log(nick.getName === peter.getName) // true
```
要注意的是，即使是這樣的寫法，但 `nick.getName()` 還是會先從 `function Person(){}` 裡面開始找，若找不到，才會找到 `Person.prototype.getName`

**也就是說，在 JS 裡面的運作是，會先從 intence 開始找，若找不到，就去找 Prototype**

找到之後就會使用了，但**如果仍找不到，就會再往更上層找**

這時候，`console.log(nick.getName === Person.prototype.getName) // true`，他們是同一個 function

那這時候可以明白，呼叫時引擎之所以知道要找 prototype，肯定是因為有一個東西將他們之間的關係串連起來了，那就是隱藏屬性 __proto__，它的目的就是如果底層找不到東西，它會指引妳去哪裏找，這個隱藏屬性在每一次你創建一個 intance 的時候就會出現

`console.log(nick.__proto___ === Person.prototype) // true`

所以可以這樣理解，如果在 nick 找不到，其實就會找向 `nick.__proto___`，而這時候的的　`nick.__proto___`　則是　`Person.prototype`

如果要研究更深，其實重點就是 `new` 這個關鍵字，

其實 `var nick = new Person('Nick');` 這個甕做可以看成以下

```javascript
var obj = {
    name = 'nick';
}
obj.__proto__ = Person.prototype
```
那如果還是找不到呢 ? 整理一下步驟

1. nick 找不到，就去找 nick.__proto__(Person.prototype)
2. 仍找不到，就去 nick.__proto__.__proto__(Person.prototype.__ptoto__)
...
...

```javascript
console.log(nick.__proto___ === Person.prototype) // true
console.log(Person.prototype.__proto___ === Object.prototype) // true
```

從 Boolean 為 true，可以知道其代表的東西是一樣的，而這邊找到就停了

請注意尋找的順序是如上所述，跟函式的宣告順序**沒有關係**

這樣的尋找順序可以看做是一條鍊，我們稱為**原型鍊 prototype chain**

# 程式執行原理 Stack

## 程式是怎麼執行的 ?

Stack 是一個資料結構，並且會符合它所屬資料結構的**特性**

在 JS 中稱之為 **Call Stack**，這個資料結構解釋了 JS 底層是如何執行的

Call Stack 符合 LIFO ，當程式在跑的時候，就會依照這個結構來跑，**Call** 的意思就是 Fubction call

