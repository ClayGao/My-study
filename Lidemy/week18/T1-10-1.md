# Gulp 加強工作流程

我們的目的就是自動化工作流程，比如說像 Week16 的 scss，我不想要每一次都要用 CLI 轉換 scss 成為 css，另外我們可以藉由 gulp 做壓縮 (雖然程式碼可能會搞到可讀性很差，但不影響效能與內容)，但是這是部署必備的流程。

所以重點：

1. 工作流程自動化
2. 壓縮檔案 (也可以編寫進自動化腳本中)

Gulp 本身是有固定語法的，先簡單介紹如下：

```javascript
var gulp = require('gulp') // 要先安裝 gulp 套件
var less = require('gule-less') // gulp 的模組之一
var minifyCSS = require('gulp-csso') // gulp 的模組之一

gulp.task('css', function() {
    return gulp.src('client/templates/*.less') // 取用我要處理的檔案，代表所有的 .less 檔案
        .pipe(less()) // 先處理
        .pipe(minifyCSS()) // 再壓縮
        .pipe(gulp.dest('build/css')) // 再把檔案輸出到 dest 資料夾
})

gulp.task('default',['css'])
```

**注意，src 通常為來源資料夾，dest 則為輸出資料夾，約定俗成的用法需要留意**

另外就是 pipe 的概念，這是之前在 Week1 課程教過的指令名稱，用處是「將前者的輸出做為後者的輸入」

其實 gulp 的格式超級好理解，以下是 [Gulp 官方網站](https://gulpjs.com/)的範例 :

```javascript
const { src, dest, parallel } = require('gulp'); // 1. 引入官方套件
// 2. 引入模組功能
const pug = require('gulp-pug');　
const less = require('gulp-less');
const minifyCSS = require('gulp-csso');
const concat = require('gulp-concat');

// 3. 設計腳本，包含來源與輸出和處理順序
function html() {
  return src('client/templates/*.pug')
    .pipe(pug())
    .pipe(dest('build/html'))
}

function css() {
  return src('client/templates/*.less')
    .pipe(less())
    .pipe(minifyCSS())
    .pipe(dest('build/css'))
}

function js() {
  return src('client/javascript/*.js', { sourcemaps: true })
    .pipe(concat('app.min.js'))
    .pipe(dest('build/js', { sourcemaps: true }))
}

//
exports.js = js;
exports.css = css;
exports.html = html;
exports.default = parallel(html, css, js);　// 4. 設定 CLI 輸入 glup 就會跑這些腳本


// 5. 在 CLI 輸入 gulp 就會開始跑腳本了(node 環境)
```

承第 5 點，既然我們是從 CLI 去執行 gulp 的，可想而知是使用 node.js 環境，並且你可以使用 npm / yarn 下載 glup

接下來開始安裝 :

```javascript
npm install --global gulp-cli -g
```
或是

```javascript
npm install --save-dev gulp
```

這樣可以把記錄檔放在 package.json 之中

接著創建一個檔案 `gulpfile.js`，這個檔名是 gulp 預設拿來執行設定檔的檔名，也就是我們放腳本程式碼的地方，在這個腳本裡面你可以做兩件事情

1. 自己寫腳本 (通常是測試 gulp 能不能 work 而已)
2. 下載套件，可以到官網的 [Pluguns](https://gulpjs.com/plugins/) 去看

我們專注在第 2 點就好，gulp 就只是一道大門而已，重點是我們要執行哪些**腳本功能**，去下載對應的**套件**

比如說現在我想要一個腳本，可以幫我將 scss 轉為 css 這件事情自動化，

```javascript


```

# Webpack

簡單來說，其中一個使用案例就是將 node 環境的 `require` 與 `import` 等功能搬到連瀏覽器環境都能使用

有同學提問說為什麼不是用 `<script>` 引入 ? 因為引入就是引入一整個檔案，不方便

用 `require` 與 `import` 的方式可以針對 function 來引入，我就可以把 function 集放在一個 func.js 檔案來用

總結 :

>Webpack 可以用類似 node.js 模組化開發

我們來開創一個檔名為 webpack.config.js 的檔案，現在來看看 Webpack 設定檔的規格 :

```javascript
const path = require('path');

module.exports = {
  entry: './src/index.js', // 引入的檔案
  output: {
    path: path.resolve(__dirname, 'dist'), // 輸出的位置
    filename: 'bundle.js' // * html 要引入的檔案
  }
};
```

要執行則是可以使用以下 CLI

```
webpack 檔名
```

執行之後轉換就成功了，成功就可以引入

引入則是以下

```html
<!doctype html>
<html>
  <head>
    ...
  </head>
  <body>
    ...
    <script src="dist/bundle.js"></script> <!-- 引入方法 -->
  </body>
</html>
```

# 其他教材補充

Webpack 概念 :

將眾多模組，如 React / sass / vue / jQuery 等等打包成一個入口點，也就是說我只要引入一個 js 檔案就好

好處 : 

1. 適合多人開發集中管理套件
2. 不用引入很多套件，讓 html 碼載入一堆，這樣在大型專案 (平台) 很難維護
3. 承上，如果引入套件有順序問題，如果一個載入有錯後續都會錯誤

所以 Webpack 的好處是把所有引入套件變成一支，透過 Webpack 打包

這邊補充下關於 node 環境家族與 Webpack 的關係 :

```
NVM
    => node
        => npm
            => Webpack
            => gulp
            => eslint...
                => Project (React, Vue, jQuery..)
```

**之所以把 NVM 放在頭，是因為我們其實可以下載 NVM 並從此安裝 node.js，可以選擇版本安裝**

這邊來示範一下 Webpack + BABEL

**Babel 就是將高版本 ES6 轉成 ES5 以下，相容性高，好工具**

首先我們在桌面創立一個資料夾

```
// Desktop

webpack
```





# Gulp 與 Webpack 的差別

- Gulp : 

    將任務**自動化**，如壓縮圖片，移動檔案，compile css，轉換 JS，minify js and css...

- Webpack :

    將資源用 `import` 的方式加載進來，包括圖片、css 等等

兩者皆用會是不錯的方法，不必非要擇一

